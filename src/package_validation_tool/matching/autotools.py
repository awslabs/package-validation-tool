# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

"""
Module to handle Autotools automation for C/C++ software projects.

This module provides functionality to detect, download, install, and run Autotools (Automake and
Autoconf) with specific versions to reproduce autotools-generated files.

Autotools are invoked only if Autotools-input files are detected in a software project. Also,
if Autotools-output files are detected in a software project, then their Autotools generation is
skipped.
"""

import hashlib
import logging
import os
import re
import subprocess
import tarfile
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from package_validation_tool.matching import AUTOTOOLS_PATCHES_DIR
from package_validation_tool.utils import (
    download_file,
    is_url_accessible,
    pushd,
    secure_tar_extractall,
)

log = logging.getLogger(__name__)

# Special case of Autoconf version that requires patching. Many OS distros (AL, Fedora, Debian) ship
# with a patched autoconf 2.69 (see the patch below), and package maintainers use this patched
# version of autoconf when running autotools on the software project source code. We apply the same
# patch, so that autoconf-generated files are exactly the same as in distro packages.
#
# FIXME: This is a hacky approach that works only for Autoconf and only for v2.69. Ideally we should
# identify the distro-specific version of Autoconf and use it. We should do the same with all other
# packages in Autotools; e.g., the same issue happens with gettext (autopoint).
AUTOCONF_VERSION_TO_PATCH = "2.69"

# default tool versions taken from Amazon Linux 2023 (as of Jun 2025)
DEFAULT_AUTOMAKE_VERSION = "1.16.5"
DEFAULT_AUTOCONF_VERSION = "2.69"
DEFAULT_GETTEXT_VERSION = "0.21"
DEFAULT_LIBTOOL_VERSION = "2.4.7"

# FTP mirror base URL for downloading Autotools packages
GNU_FTP_BASE_URL = "https://mirrors.ocf.berkeley.edu/gnu/"

# Tool configuration - consolidates all tool-specific information
TOOL_CONFIGS = {
    "automake": {
        "default_version": DEFAULT_AUTOMAKE_VERSION,
        "verification_files": ["Makefile.am", "Makefile.in"],
        "detection_files": [
            ("aclocal.m4", r"generated automatically by aclocal (\d+(?:\.\d+)*)"),
            ("Makefile.in", r"generated by automake (\d+(?:\.\d+)*)"),
        ],
        "sha256_hashsums": {
            "automake-1.11.2.tar.gz": "c339e3871d6595620760725da61de02cf1c293af8a05b14592d6587ac39ce546",
            "automake-1.11.3.tar.gz": "921b5188057e57bdd9c0ba06e21d0b0ea7dafa61a9bd08a2b041215bcff12f55",
            "automake-1.11.4.tar.gz": "ed27d3bf15c5dee507806d3359abb2bac8c18a4b8bc38c5de8babb356a2f761d",
            "automake-1.11.5.tar.gz": "dff78abadb54962fec62b5c0f9a79a6cdd86c7daad90469ea7da06e0553ac566",
            "automake-1.11.6.tar.gz": "53dbf1945401c43f4ce19c1971baecdbf8bc32e0f37fa3f49fe7b6992d0d2030",
            "automake-1.12.tar.gz": "6dcc0c5971c74da369dda00fceaf5416c1f186d635eb14cc301d1ce29e5a9a26",
            "automake-1.12.1.tar.gz": "24bf1640679ba4a9cbe2d36422f39a81eced7f556b576a7a2ccfc70ca85a1e2f",
            "automake-1.12.2.tar.gz": "b2eef742f42730831d1af2fe0e5b954e2b60773e2e9922ba6280cdd0ab4a5d00",
            "automake-1.12.3.tar.gz": "095ffaa3ac887d1eb3511bf13d7f1fc9ec0503c6a06aeae05c93730cdda9a5a0",
            "automake-1.12.4.tar.gz": "9a3cbb21e7a96d93f726129e8aa4bc3c43ed422da661f70a6eb21d1b49327aca",
            "automake-1.12.5.tar.gz": "82089e23b384d3e64efa4f09f133a02dadb91c0593d4f1d4e12c29d806be9925",
            "automake-1.12.6.tar.gz": "0cbe570db487908e70af7119da85ba04f7e28656b26f717df0265ae08defd9ef",
            "automake-1.13.tar.gz": "80525fa3832cb0673561a57abb5958f62cb4177e30b5d56187e9c99580f0848f",
            "automake-1.13.1.tar.gz": "51bc10031847e9965c4f2c16a0a66552309ce28ea82b1afa8cef736643ebaa27",
            "automake-1.13.2.tar.gz": "958fad527921001c27a149af2661be3cf29b9fde078fc5f04a4a17daf6282bb4",
            "automake-1.13.3.tar.gz": "883c91fb7eff735cd426d7ecf4279693e2f58442d5695760f3f66090a6758dbc",
            "automake-1.13.4.tar.gz": "4c93abc0bff54b296f41f92dd3aa1e73e554265a6f719df465574983ef6f878c",
            "automake-1.14.tar.gz": "7847424d4204d1627c129e9c15b81e145836afa2a1bf9003ffe10aa26ea75755",
            "automake-1.14.1.tar.gz": "814c2333f350ce00034a1fe718e0e4239998ceea7b0aff67e9fd273ed6dfc23b",
            "automake-1.15.tar.gz": "7946e945a96e28152ba5a6beb0625ca715c6e32ac55f2e353ef54def0c8ed924",
            "automake-1.15.1.tar.gz": "988e32527abe052307d21c8ca000aa238b914df363a617e38f4fb89f5abf6260",
            "automake-1.16.tar.gz": "80da43bb5665596ee389e6d8b64b4f122ea4b92a685b1dbd813cd1f0e0c2d83f",
            "automake-1.16.1.tar.gz": "608a97523f97db32f1f5d5615c98ca69326ced2054c9f82e65bade7fc4c9dea8",
            "automake-1.16.2.tar.gz": "b2f361094b410b4acbf4efba7337bdb786335ca09eb2518635a09fb7319ca5c1",
            "automake-1.16.3.tar.gz": "ce010788b51f64511a1e9bb2a1ec626037c6d0e7ede32c1c103611b9d3cba65f",
            "automake-1.16.4.tar.gz": "8a0f0be7aaae2efa3a68482af28e5872d8830b9813a6a932a2571eac63ca1794",
            "automake-1.16.5.tar.gz": "07bd24ad08a64bc17250ce09ec56e921d6343903943e99ccf63bbf0705e34605",
            "automake-1.17.tar.gz": "397767d4db3018dd4440825b60c64258b636eaf6bf99ac8b0897f06c89310acd",
            "automake-1.18.tar.gz": "af6043a5d4b3beef0c48161f4a6936259321cd101a34c1ab0768328515626c8a",
            "automake-1.18.1.tar.gz": "63e585246d0fc8772dffdee0724f2f988146d1a3f1c756a3dc5cfbefa3c01915",
        },
    },
    "autoconf": {
        "default_version": DEFAULT_AUTOCONF_VERSION,
        "verification_files": ["configure.ac", "configure.in"],
        "detection_files": [("configure", r"Generated by GNU Autoconf (\d+(?:\.\d+)*)")],
        "sha256_hashsums": {
            "autoconf-2.66.tar.gz": "302ce4fd28ef39fda650b9d06cfe568ae46b2d0b4e0a4982dc51757937c935bb",
            "autoconf-2.67.tar.gz": "26b752c4276472d3b21fa2a6cfdfb4957e39d5d6108a4f4020b13234ffba66d1",
            "autoconf-2.68.tar.gz": "eff70a2916f2e2b3ed7fe8a2d7e63d72cf3a23684b56456b319c3ebce0705d99",
            "autoconf-2.69.tar.gz": "954bd69b391edc12d6a4a51a2dd1476543da5c6bbf05a95b59dc0dd6fd4c2969",
            "autoconf-2.70.tar.gz": "f05f410fda74323ada4bdc4610db37f8dbd556602ba65bc843edb4d4d4a1b2b7",
            "autoconf-2.71.tar.gz": "431075ad0bf529ef13cb41e9042c542381103e80015686222b8a9d4abef42a1c",
            "autoconf-2.72.tar.gz": "afb181a76e1ee72832f6581c0eddf8df032b83e2e0239ef79ebedc4467d92d6e",
        },
    },
    "gettext": {
        "default_version": DEFAULT_GETTEXT_VERSION,
        "detection_files": [
            ("gettext.m4", r"gettext-(\d+(?:\.\d+)*(?:\.\d+)*)"),
            ("m4/gettext.m4", r"gettext-(\d+(?:\.\d+)*(?:\.\d+)*)"),
        ],
        "sha256_hashsums": {
            "gettext-0.18.1.tar.gz": "37a947bbae63c3173a2e2caa0e61f82b86c23f3e3f012f8f309eeaf90d839c7b",
            "gettext-0.18.1.1.tar.gz": "93ac71a7afa5b70c1b1032516663658c51e653087f42a3fc8044752c026443e9",
            "gettext-0.18.2.tar.gz": "516a6370b3b3f46e2fc5a5e222ff5ecd76f3089bc956a7587a6e4f89de17714c",
            "gettext-0.18.2.1.tar.gz": "32fc1b85fc249ab81bfc37b942a992c7a34f2e1101357ce0d4591341b9164a0a",
            "gettext-0.18.3.tar.gz": "36f3c1043df803565d4977c1efbd41e1ec0f0301acf5f057984406c34cb9f948",
            "gettext-0.18.3.1.tar.gz": "0d8f9a33531b77776b3dc473e7940019ca19bfca5b4c06db6e96065eeb07245d",
            "gettext-0.18.3.2.tar.gz": "d1a4e452d60eb407ab0305976529a45c18124bd518d976971ac6dc7aa8b4c5d7",
            "gettext-0.18.tar.gz": "02342c1de18c03c601f8b91cbd896b70486a4b945bd816f34541e0d7b5a96fe5",
            "gettext-0.19.tar.gz": "a9f9c7764bc68782aca57687a1f16c228bc321069c538325923513b841bd847c",
            "gettext-0.19.1.tar.gz": "287471d95bdf5feb48626247fdc530660e3d2906a57a141603893772240101c6",
            "gettext-0.19.2.tar.gz": "0c48ae6ef6e0abcf6cd9cb9dcdc593d0e1a367e82259bbe113ce88ceea9249bb",
            "gettext-0.19.3.tar.gz": "93952d505a3d3b1ec10c69d340c7d438b1f9c332710d583981c0608be3eeb3f6",
            "gettext-0.19.4.tar.gz": "8ac9f1ed1a5f8c4e656a2f37f5ba6b9ee04c4df79a575e876b0b6946aa417f3f",
            "gettext-0.19.5.1.tar.gz": "a198d53b0c1fb11421ead197b7e76b144e887c9ef5a685323e92cbc950227731",
            "gettext-0.19.5.tar.gz": "1258814ba174e4783194be2dc93648bd630d4dda166eae034e4ad54489dcf73a",
            "gettext-0.19.6.tar.gz": "ed4b4c19bd3a3034eb6769500a3592ff616759ef43cf30586dbb7a17c9dd695d",
            "gettext-0.19.7.tar.gz": "5386d2a40500295783c6a52121adcf42a25519e2d23675950619c9e69558c23f",
            "gettext-0.19.8.1.tar.gz": "ff942af0e438ced4a8b0ea4b0b6e0d6d657157c5e2364de57baa279c1c125c43",
            "gettext-0.19.8.tar.gz": "3da4f6bd79685648ecf46dab51d66fcdddc156f41ed07e580a696a38ac61d48f",
            "gettext-0.20.tar.gz": "5194991e786f1e98fe9682449a7630f03deea201c7f0d668eea28cd31a800dff",
            "gettext-0.20.1.tar.gz": "66415634c6e8c3fa8b71362879ec7575e27da43da562c798a8a2f223e6e47f5c",
            "gettext-0.20.2.tar.gz": "ecb9d0908ca41d5ca5fef974323b3bba6bec19eebba0b44f396de98cfcc089f1",
            "gettext-0.21.tar.gz": "c77d0da3102aec9c07f43671e60611ebff89a996ef159497ce8e59d075786b12",
            "gettext-0.21.1.tar.gz": "e8c3650e1d8cee875c4f355642382c1df83058bd5a11ee8555c0cf276d646d45",
            "gettext-0.22.tar.gz": "49f089be11b490170bbf09ed2f51e5f5177f55be4cc66504a5861820e0fb06ab",
            "gettext-0.22.1.tar.gz": "e509953988e8b4b3e6456faada9ae90ee74b09b442eb06cb7cbe089617fbad85",
            "gettext-0.22.2.tar.gz": "a99662bafc1cc683ec7740844b465c7f30ccb044967f157f74697df9a9306b0e",
            "gettext-0.22.3.tar.gz": "839a260b2314ba66274dae7d245ec19fce190a3aa67869bf31354cb558df42c7",
            "gettext-0.22.4.tar.gz": "c1e0bb2a4427a9024390c662cd532d664c4b36b8ff444ed5e54b115fdb7a1aea",
            "gettext-0.22.5.tar.gz": "ec1705b1e969b83a9f073144ec806151db88127f5e40fe5a94cb6c8fa48996a0",
            "gettext-0.23.tar.gz": "945dd7002a02dd7108ad0510602e13416b41d327898cf8522201bc6af10907a6",
            "gettext-0.23.1.tar.gz": "52a578960fe308742367d75cd1dff8552c5797bd0beba7639e12bdcda28c0e49",
            "gettext-0.23.2.tar.gz": "40e21f07b71199fb2796fc43cee82635928eca244c62d3768f581adf928b4f06",
            "gettext-0.24.tar.gz": "c918503d593d70daf4844d175a13d816afacb667c06fba1ec9dcd5002c1518b7",
            "gettext-0.24.1.tar.gz": "7387ec048971a1b42c0aab866c51222f63af3cf51938695f555609c33d89e486",
            "gettext-0.24.2.tar.gz": "bff3a4fe50892c1a352c19b17af4342096d2210e21b95bacfb1c3dd6e46c9218",
            "gettext-0.25.tar.gz": "aee02dab79d9138fdcc7226b67ec985121bce6007edebe30d0e39d42f69a340e",
            "gettext-0.25.1.tar.gz": "746f955d42d71eb69ce763869cb92682f09a4066528d018b6ca7a3f48089a085",
        },
    },
    "libtool": {
        "default_version": DEFAULT_LIBTOOL_VERSION,
        "detection_files": [
            ("ltmain.sh", r"libtool \(GNU libtool\) (\d+(?:\.\d+)*(?:\.\d+)*)"),
            ("build-aux/ltmain.sh", r"libtool \(GNU libtool\) (\d+(?:\.\d+)*(?:\.\d+)*)"),
            ("config/ltmain.sh", r"libtool \(GNU libtool\) (\d+(?:\.\d+)*(?:\.\d+)*)"),
        ],
        "sha256_hashsums": {
            "libtool-2.2.8.tar.gz": "02a7c2fd72629f093a34e7a8d1a22912af0645d42e5bbe95767aa94d1e4173d0",
            "libtool-2.2.10.tar.gz": "de7d1d028fa3be15a05b3e00fe64f80ece62636923cc9ef82dc8b9a2f3c5d77d",
            "libtool-2.4.tar.gz": "13df57ab63a94e196c5d6e95d64e53262834fe780d5e82c28f177f9f71ddf62e",
            "libtool-2.4.2.tar.gz": "b38de44862a987293cd3d8dfae1c409d514b6c4e794ebc93648febf9afc38918",
            "libtool-2.4.3.tar.gz": "36b4881c1843d7585de9c66c4c3d9a067ed3a3f792bc670beba21f5a4960acdf",
            "libtool-2.4.4.tar.gz": "159d4e20c201f929e3562536d3ae6b5e605403fa4bb4e72ef197a4e162c3fedf",
            "libtool-2.4.5.tar.gz": "509cb49c7de14ce7eaf88993cf09fd4071882699dfd874c2e95b31ab107d6987",
            "libtool-2.4.6.tar.gz": "e3bd4d5d3d025a36c21dd6af7ea818a2afcd4dfc1ea5a17b39d7854bcd0c06e3",
            "libtool-2.4.7.tar.gz": "04e96c2404ea70c590c546eba4202a4e12722c640016c12b9b2f1ce3d481e9a8",
            "libtool-2.5.3.tar.gz": "9322bd8f6bc848fda3e385899dd1934957169652acef716d19d19d24053abb95",
            "libtool-2.5.4.tar.gz": "da8ebb2ce4dcf46b90098daf962cffa68f4b4f62ea60f798d0ef12929ede6adf",
        },
    },
}


class AutotoolsRunner:
    """
    Autotools automation runner for C/C++ software projects.

    This class handles the detection, download, installation, and execution of Autotools (Automake
    and Autoconf) with specific versions to reproduce autotools-generated files exactly as they
    appear in package archives.
    """

    def __init__(self, autotools_dir: str, src_repo_dir: str, package_archive_dir: str):
        """
        Initialize the AutotoolsRunner.

        Args:
            autotools_dir: Directory where Autotools tools will be downloaded and installed
            src_repo_dir: Directory containing the source code of the software project
            package_archive_dir: Directory containing the autotools-applied source code archive
        """
        self._tool_versions: Dict[str, Optional[str]] = {tool: None for tool in TOOL_CONFIGS}

        self.autotools_dir = Path(autotools_dir).resolve()
        self.src_repo_dir = Path(src_repo_dir).resolve()
        self.package_archive_dir = Path(package_archive_dir).resolve()

        self.autotools_dir.mkdir(parents=True, exist_ok=True)

        log.debug("AutotoolsRunner initialized with:")
        log.debug("  autotools_dir: %s", self.autotools_dir)
        log.debug("  src_repo_dir: %s", self.src_repo_dir)
        log.debug("  package_archive_dir: %s", self.package_archive_dir)

    def run_autotools(self) -> bool:
        """
        Main method to run all Autotools steps.

        This method executes the complete Autotools workflow:
        1. Verify the project uses Autotools
        2. Detect required Autotools versions
        3. Download Autotools packages
        4. Install Autotools packages locally
        5. Generate files using Autotools

        Returns:
            bool: True if all steps completed successfully, False otherwise
        """
        log.info("Starting Autotools processing...")

        if not self._verify_uses_autotools():
            log.info("Software project does not use Autotools, nothing to do")
            return True

        log.info("Software project uses Autotools, proceeding with version detection...")
        detected_versions = self._detect_autotools_versions()

        # Apply detected versions with fallback to defaults
        for tool, version in detected_versions.items():
            if not version:
                version = TOOL_CONFIGS[tool]["default_version"]
                log.warning(
                    "%s version wasn't determined, assigned predefined value %s "
                    "(may lead to differently generated files)",
                    tool.capitalize(),
                    version,
                )
            self._tool_versions[tool] = version

        log.info(
            "Detected versions: %s",
            ", ".join(
                f"{tool.capitalize()}: {version}" for tool, version in self._tool_versions.items()
            ),
        )

        if not self._download_autotools_packages():
            log.error("Failed to download required Autotools packages")
            return False

        tool_paths = self._install_autotools_packages()

        if not any(tool_paths.values()):
            log.error("Failed to install any Autotools packages")
            return False

        if not self._generate_autotools_files(tool_paths):
            log.error("Failed to generate files using Autotools")
            return False

        log.info("Autotools processing completed successfully")
        return True

    def get_detected_versions(self) -> Dict[str, Optional[str]]:
        """Get detected Autotools versions: dict of "tool: version" key pairs."""
        return self._tool_versions.copy()

    def _verify_uses_autotools(self) -> bool:
        """Verify that the software project uses Autotools for build."""

        # Check only tools that have verification files (automake and autoconf)
        verification_tools = {
            tool: config for tool, config in TOOL_CONFIGS.items() if "verification_files" in config
        }

        for tool, config in verification_tools.items():
            files = config["verification_files"]
            for filename in files:
                filepath = self.src_repo_dir / filename
                if filepath.is_file():
                    log.debug("Found %s file: %s", tool.capitalize(), filename)
                    log.info("Project uses Autotools: True")
                    return True

        log.info("Project uses Autotools: False")
        return False

    def _detect_autotools_versions(self) -> Dict[str, Optional[str]]:
        """
        Detect required Autotools versions from the package archive.

        Returns:
            Dict[str, Optional[str]]: Dictionary mapping tool names to their detected versions
        """

        versions = {}
        for tool, config in TOOL_CONFIGS.items():
            version = self._detect_tool_version(config["detection_files"])
            if version:
                if tool == "libtool":
                    # Extract only up to 3 numbers (e.g., "2.4.6" from "2.4.6.42-b88ce-dirty")
                    version_parts = version.split(".")
                    if len(version_parts) > 3:
                        version = ".".join(version_parts[:3])
                log.debug("Found %s version %s", tool.capitalize(), version)
            versions[tool] = version

        return versions

    def _detect_tool_version(self, detection_files: List[Tuple[str, str]]) -> Optional[str]:
        """Detect tool version from specified files using regex patterns."""
        for filename, pattern in detection_files:
            filepath = self.package_archive_dir / filename
            if filepath.is_file():
                version = self._extract_version_from_file(filepath, pattern)
                if version:
                    return version
        return None

    def _extract_version_from_file(self, filepath: Path, pattern: str) -> Optional[str]:
        """Extract version information from first 10 lines of a file using regex pattern."""
        try:
            with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
                for i, line in enumerate(f):
                    if i >= 10:
                        break
                    match = re.search(pattern, line)
                    if match:
                        return match.group(1)
        except Exception as e:
            log.debug("Error reading file %s: %r", filepath, e)

        return None

    def _download_autotools_packages(self) -> bool:
        """Download Autotools packages with detected versions."""
        success = True
        for tool, version in self._tool_versions.items():
            if not self._download_package(tool, version):
                log.warning("Failed to download %s version %s", tool.capitalize(), version)
                success = False

        return success

    def _download_package(self, package_name: str, version: str) -> bool:
        """Download a specific Autotools package and verify its SHA256 checksum."""
        archive_name = f"{package_name}-{version}.tar.gz"
        local_path = self.autotools_dir / archive_name

        if local_path.is_file():
            log.debug("Package %s already exists at %s", archive_name, local_path)
            # Verify checksum even for existing files
            if not self._verify_checksum(package_name, archive_name, local_path):
                log.error("Checksum verification failed for existing file %s", archive_name)
                return False
            return True

        url = f"{GNU_FTP_BASE_URL}{package_name}/{archive_name}"
        if not is_url_accessible(url):
            log.error("URL is not accessible: %s", url)
            return False

        max_retries = 2
        for attempt in range(max_retries + 1):
            if attempt > 0:
                log.info("Retrying download (attempt %d/%d)...", attempt + 1, max_retries + 1)
                time.sleep(2)  # wait between retries

            if download_file(url, str(local_path)):
                log.info("Successfully downloaded %s", archive_name)
                # Verify checksum after successful download
                if not self._verify_checksum(package_name, archive_name, local_path):
                    log.error("Checksum verification failed for downloaded file %s", archive_name)
                    try:
                        local_path.unlink()
                    except Exception as e:
                        log.warning("Failed to remove corrupted file %s: %r", local_path, e)
                    return False
                return True
            else:
                log.warning("Download attempt %d failed for %s", attempt + 1, archive_name)

        log.error("Failed to download %s after %d attempts", archive_name, max_retries + 1)
        return False

    def _verify_checksum(self, package_name: str, archive_name: str, local_path: Path) -> bool:
        """Verify SHA256 checksum of a downloaded package."""
        expected_checksum = TOOL_CONFIGS[package_name]["sha256_hashsums"].get(archive_name)

        if not expected_checksum:
            log.warning(
                "No expected checksum found for %s. This may indicate a newer version of %s that hasn't been "
                "added to the tool yet. Please contact the tool developers to request support for "
                "this version, or check if a newer version of the Package Validation Tool is available.",
                archive_name,
                package_name.capitalize(),
            )
            return False

        try:
            sha256_hash = hashlib.sha256()
            with open(local_path, "rb") as f:
                # Read file in chunks to handle large files efficiently
                for chunk in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(chunk)

            actual_checksum = sha256_hash.hexdigest()

            if actual_checksum == expected_checksum:
                log.debug("Checksum verification passed for %s", archive_name)
                return True
            else:
                log.error(
                    "Checksum verification failed for %s. Expected: %s, Got: %s",
                    archive_name,
                    expected_checksum,
                    actual_checksum,
                )
                return False

        except Exception as e:
            log.error("Error calculating checksum for %s: %r", archive_name, e)
            return False

    def _install_autotools_packages(self) -> Dict[str, Optional[str]]:
        """
        Install Autotools packages under autotools_dir (i.e. not system wide).

        Returns:
            Dict[str, Optional[str]]: Dictionary mapping tool names to their bin directory paths
        """
        tool_paths = {}
        for tool, version in self._tool_versions.items():
            path = self._install_package(tool, version)
            if path:
                log.info("%s %s installed at %s", tool.capitalize(), version, path)
            else:
                log.error("Failed to install %s %s", tool.capitalize(), version)
            tool_paths[tool] = path

        return tool_paths

    def _install_package(self, package_name: str, version: str) -> Optional[str]:
        """Install a specific Autotools package. Returns path to the installed bin dir."""
        archive_name = f"{package_name}-{version}.tar.gz"
        archive_path = self.autotools_dir / archive_name
        extract_dir = self.autotools_dir / f"{package_name}-{version}"
        bin_dir = extract_dir / "installed" / "bin"

        if bin_dir.is_dir():
            log.debug("Package %s-%s already installed at %s", package_name, version, bin_dir)
            return str(bin_dir)

        if not archive_path.is_file():
            log.error("Archive not found: %s", archive_path)
            return None

        try:
            with tarfile.open(archive_path, "r:gz") as tar:
                if not secure_tar_extractall(tar, self.autotools_dir):
                    log.error("Failed to securely extract %s", archive_path)
                    return None

            # cd to extracted dir and run ./configure --prefix=<install-dir>; make; make install
            with pushd(str(extract_dir)):
                install_prefix = extract_dir / "installed"

                if package_name == "autoconf" and version == AUTOCONF_VERSION_TO_PATCH:
                    log.info(
                        "Applying patch for autoconf %s (special case of runstatedir backport)",
                        version,
                    )

                    patch_file = (
                        AUTOTOOLS_PATCHES_DIR / "autoconf-2.69-backport-runstatedir-option.patch"
                    )
                    if not patch_file.is_file():
                        log.error("Cannot find autoconf patch %s", patch_file)
                        return None

                    # Apply the patch
                    with open(patch_file, "r", encoding="utf-8") as f:
                        patch_content = f.read()

                    patch_result = subprocess.run(
                        ["patch", "-p1"],
                        input=patch_content,
                        text=True,
                        capture_output=True,
                        check=False,
                    )
                    if patch_result.returncode != 0:
                        log.error(
                            "Failed to apply patch to autoconf %s: %s", version, patch_result.stderr
                        )
                        return None
                    log.info("Successfully applied patch to autoconf %s", version)

                # Run build steps
                build_steps = [
                    (["./configure", f"--prefix={install_prefix}"], "Configure"),
                    (["make"], "Make"),
                    (["make", "install"], "Make install"),
                ]

                for cmd, step_name in build_steps:
                    result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                    if result.returncode != 0:
                        log.error(
                            "%s failed for %s-%s: %s",
                            step_name,
                            package_name,
                            version,
                            result.stderr,
                        )
                        return None

            if bin_dir.is_dir():
                log.debug("Successfully installed %s-%s at %s", package_name, version, bin_dir)
                return str(bin_dir)
            else:
                log.error("Installation directory not found after installation: %s", bin_dir)
                return None

        except Exception as e:
            log.error("Error installing %s-%s: %r", package_name, version, e)
            return None

    def _generate_autotools_files(self, tool_paths: Dict[str, Optional[str]]) -> bool:
        """
        Generate files using Autotools in source repo directory.

        File Generation Flow (order matters due to dependencies):
        ========================================================

        Source Files          Tools (Package)       Generated Files
        ------------          ---------------       ---------------
        (various files)  ---> autopoint       ---> (various gettext files)
                              (Gettext)

        (various files)  ---> libtoolize      ---> (various libtool files)
                              (Libtool)

        configure.ac     ---> aclocal         ---> aclocal.m4
        configure.in          (Automake)

        aclocal.m4       \
        configure.ac      |-> autoconf        ---> configure
        configure.in     /    (Autoconf)

        configure.ac     ---> autoheader      ---> config.h.in
        configure.in          (Autoconf)

        Makefile.am      ---> automake        ---> Makefile.in
                              (Automake)

        Note: configure.ac and configure.in are equivalent (latter is deprecated).
              See the tutorial https://www.lrde.epita.fr/~adl/autotools.html for generation order.

        Args:
            tool_paths: Dictionary mapping tool names to their bin directory paths

        Returns:
            bool: True if all files were generated successfully, False otherwise
        """
        log.info("Generating Autotools files in source repository...")

        # prepare PATH environment variable
        env = os.environ.copy()
        path_parts = [path for path in tool_paths.values() if path]

        if path_parts:
            env["PATH"] = ":".join(path_parts) + ":" + env.get("PATH", "")
            log.debug("Updated PATH: %s", env["PATH"])

        success = True

        with pushd(str(self.src_repo_dir)):
            # some software projects provide M4 macros under m4/ or macros/ dirs; use them
            m4_includes = []
            if Path(self.src_repo_dir / "m4").is_dir():
                m4_includes.extend(["-I", "m4"])
            if Path(self.src_repo_dir / "macros").is_dir():
                m4_includes.extend(["-I", "macros"])

            # First run autopoint and libtoolize (always run, no file checks needed)
            initial_commands = [
                ("autopoint", "gettext", []),
                ("libtoolize", "libtool", []),
            ]

            for command, tool, args in initial_commands:
                if tool_paths.get(tool):
                    if not self._run_autotools_command(command, env, args):
                        success = False

            # files to generate in order (order is important for dependencies)
            files_to_generate = [
                ("aclocal.m4", "aclocal", "automake", m4_includes),
                ("configure", "autoconf", "autoconf", []),
                ("config.h.in", "autoheader", "autoconf", []),
                ("Makefile.in", "automake", "automake", ["--add-missing", "--foreign"]),
            ]

            for filename, command, tool, args in files_to_generate:
                # skip if tool is not available
                if not tool_paths.get(tool):
                    continue

                if not self._should_generate_file(filename):
                    continue

                if not self._run_autotools_command(command, env, args):
                    log.warning("Failed to generate %s", filename)
                    success = False
                elif not self._verify_file_generated(filename):
                    log.warning("%s was not generated", filename)
                    success = False

        return success

    def _should_generate_file(self, filename: str) -> bool:
        """Check if a file should be generated (doesn't already exist)."""
        filepath = self.src_repo_dir / filename
        exists = filepath.is_file()

        if exists:
            log.debug("File %s already exists, skipping generation", filename)
            return False
        else:
            log.debug("File %s does not exist, will generate", filename)
            return True

    def _run_autotools_command(self, command: str, env: dict, args: list = None) -> bool:
        """
        Run an Autotools command with proper environment.

        Args:
            command: The command to run (e.g., "autoheader", "aclocal")
            env: Environment variables to use
            args: Additional arguments for the command

        Returns:
            bool: True if command succeeded, False otherwise
        """
        cmd = [command]
        if args:
            cmd.extend(args)

        log.debug("Running command: %s", " ".join(cmd))

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False, env=env)

            if result.returncode == 0:
                log.debug("Command succeeded: %s", " ".join(cmd))
                return True
            else:
                log.error("Command failed: %s", " ".join(cmd))
                return False

        except Exception as e:
            log.error("Error running command %s: %r", " ".join(cmd), e)
            return False

    def _verify_file_generated(self, filename: str) -> bool:
        """Verify that a file was generated successfully."""
        filepath = self.src_repo_dir / filename
        exists = filepath.is_file()

        if exists:
            log.debug("Verified file generated: %s", filename)
        else:
            log.error("File not found after generation: %s", filename)

        return exists
